# -*- coding: utf-8 -*-
"""Adkins_J_HW1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l4cPKA4MfRWUdUuN2aTSiZg3uoAX7m9F
"""

# Importing Libraries
import pandas as pd # This imports the Panda library
import numpy as np # This imports NumPy

# Question 1:
np.__version__

# Importing the car data
! wget https://raw.githubusercontent.com/alexeygrigorev/mlbookcamp-code/master/chapter-02-car-price/data.csv

# Question 2:
df = pd.read_csv("data.csv") # Setting up variable for data frame(df);
# referencing panda library; to read the imported csv file.

df.shape # Returns the dimensions of the dataset in ordered pair (row,column)

df.head() # Returns the first five rows of the dataset.

df.tail() # Returns the last five rows of the dataset.

df.info() # Returns the information about the dataframe; data types, columns,
# null counts, etc.

# Question 3:
df.Make.value_counts().sort_values(ascending = False) # Returns the number of 
#instances each string appears in descending order.

df.Make.value_counts().sort_values() # Returns the number of 
# instances each string appears in ascending order. Ascending is default setting

# Question 4:
df.Model[df.Make == 'Audi'].nunique() # This generates count of unique values of
# models for a particular make; runs a comparison of all the models and only
# returns the number of make corresponding to Audi. Note "n" before unique.

df.Model[df.Make == 'Audi'].unique() # This generates an array of the unique
# models corresponding to Audi.

# Question 5:
nulls = df.isnull().sum() # Save the variable of the number of null values in
# each column. This will not generate any output. We generated a query and
# saved it to a variable. The sum returns the total count of null values for
# each column.
nulls[nulls > 0].count() # The count will return how many values have condition
# more than zero; the condition being how many null values there are that are 
# greater than zero.

# Question 6:
# 6.1

df["Engine Cylinders"].median() # Generates the median value in the for the
# column "Engine Cylinders" in the data frame.

# 6.2

df["Engine Cylinders"].mode() # Generates the most frequent value for the
# "Engine Cylinders" column.

# 6.3

df["Engine Cylinders"].fillna(df["Engine Cylinders"].mode(), inplace= True)
# Imputes the most frequent value, into where the missing values are present.

# 6.4

df["Engine Cylinders"].median() # Recalculate the median value; unchanged.

# Questions 7:
# 7.1

Lotus = df[df["Make"] == "Lotus"] # We set a variable, Lotus to select all the
# Lotus cars from the dataset.
Lotus.head() # Displayed the first five rows of the dataset.

# 7.2

Engine_Columns = Lotus[["Engine HP","Engine Cylinders"]] # Selected the columns
# Engine HP and Engine Cylinders.
Engine_Columns.head() # Display the first five rows.

# 7.3

X = Engine_Columns.drop_duplicates(inplace = True) # Set X to equal the Engine 
# columns where we dropped the dupicates.

# 7.4
X = Engine_Columns.values # Getting the values from the Engine_Columns as an
# array

X # Display X

# 7.5

XTX = X.T.dot(X) # Dot product for X and X transposed using linear algebra
# library.

XTX # Display XTX

# 7.6

XTX_inverted = np.linalg.inv(XTX) # Invert XTX using a linear algebra library.

XTX_inverted # Display XTX_inverted

# 7.7

y = np.array([1100, 800, 750, 850, 1300, 1000, 1000, 1300, 800])
# Inputing an array.

y # Display y

# 7.8

w = XTX_inverted.dot(X.T).dot(y)
# Taking the dot product for X transposed, X transposed inverted, y.

w # Display w

# 7.9

w[0].round(4) # The value of the first element of w rounded to four digits.